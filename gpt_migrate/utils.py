import os
import typer
from yaspin import yaspin
from pathlib import Path
from collections import Counter
import fnmatch
import re
import shutil
from config import INCLUDED_EXTENSIONS, EXTENSION_TO_LANGUAGE

def detect_language(source_directory):
    """
    Detects the language used in the source directory based on the most common file extension.

    Args:
        source_directory (str): The path to the source directory.

    Returns:
        str: The language detected based on the most common file extension, or None if no language is detected.
    """
    file_extensions = []

    for filenames in os.walk(source_directory):
        for filename in filenames[2]:
            ext = filename.split('.')[-1]
            file_extensions.append(ext)
    
    extension_counts = Counter(file_extensions)
    most_common_extension, _ = extension_counts.most_common(1)[0]
    
    # Determine the language based on the most common file extension
    language = EXTENSION_TO_LANGUAGE.get(most_common_extension, None)
    
    return language

def prompt_constructor(*args):
    """
    Constructs a prompt by combining content from multiple files.

    Args:
        *args (str): The names of the files to read from.

    Returns:
        str: The combined content of the specified files.
    """
    prompt = ""
    for arg in args:
        with open(os.path.abspath(f'prompts/{arg}'), 'r') as file:
            prompt += file.read().strip()
    return prompt

def llm_run(prompt,waiting_message,success_message,globals):
    """
    Runs a prompt using the AI model.

    Args:
        prompt (str): The prompt to run.
        waiting_message (str): The message to display while waiting for the AI model to process the prompt.
        success_message (str): The message to display when the prompt is successfully processed.
        globals: The global variables.

    Returns:
        str: The output generated by the AI model.
    """
    output = ""
    with yaspin(text=waiting_message, spinner="dots") as spinner:
        output = globals.ai.run(prompt)
        spinner.ok("✅ ")

    if success_message:
        success_text = typer.style(success_message, fg=typer.colors.GREEN)
        typer.echo(success_text)
    
    return output

def llm_write_file(prompt,target_path,waiting_message,success_message,globals):
    """
    Writes a code file generated by the AI model to the target path.

    Args:
        prompt (str): The prompt used to generate the code file.
        target_path (str): The target path where the code file should be written.
        waiting_message (str): The message to display while waiting for the AI model to generate the code file.
        success_message (str): The message to display when the code file is successfully generated and written.
        globals: The global variables.

    Returns:
        str: The name of the code file generated.
        str: The language of the code file.
        str: The content of the code file.
    """
    file_content = ""
    with yaspin(text=waiting_message, spinner="dots") as spinner:
        file_name,language,file_content = globals.ai.write_code(prompt)[0]
        spinner.ok("✅ ")
    
    if file_name=="INSTRUCTIONS:":
        return "INSTRUCTIONS:","",file_content

    if target_path:
        with open(os.path.join(globals.targetdir, target_path), 'w') as file:
            file.write(file_content)
    else:
        with open(os.path.join(globals.targetdir, file_name), 'w') as file:
            file.write(file_content)

    if success_message:
        success_text = typer.style(success_message, fg=typer.colors.GREEN)
        typer.echo(success_text)
    else:
        success_text = typer.style(f"Created {file_name} at {globals.targetdir}", fg=typer.colors.GREEN)
        typer.echo(success_text)
    
    return file_name, language, file_content

def llm_write_files(prompt,target_path,waiting_message,success_message,globals):
    """
    Writes multiple code files generated by the AI model to the target path.

    Args:
        prompt (str): The prompt used to generate the code files.
        target_path (str): The target path where the code files should be written.
        waiting_message (str): The message to display while waiting for the AI model to generate the code files.
        success_message (str): The message to display when the code files are successfully generated and written.
        globals: The global variables.

    Returns:
        list: A list of tuples containing the names, languages, and contents of the code files generated.
    """
    file_content = ""
    with yaspin(text=waiting_message, spinner="dots") as spinner:
        results = globals.ai.write_code(prompt)
        spinner.ok("✅ ")

    for result in results:
        file_name,language,file_content = result

        if target_path:
            with open(os.path.join(globals.targetdir, target_path), 'w') as file:
                file.write(file_content)
        else:
            with open(os.path.join(globals.targetdir, file_name), 'w') as file:
                file.write(file_content)

        if not success_message:
            success_text = typer.style(f"Created {file_name} at {globals.targetdir}", fg=typer.colors.GREEN)
            typer.echo(success_text)
    if success_message:
        success_text = typer.style(success_message, fg=typer.colors.GREEN)
        typer.echo(success_text)
    
    return results

def load_templates_from_directory(directory_path):
    """
    Loads templates from a directory.

    Args:
        directory_path (str): The path to the directory containing the templates.

    Returns:
        dict: A dictionary mapping template names to their contents.
    """
    templates = {}
    for filename in os.listdir(directory_path):
        with open(os.path.join(directory_path, filename), 'r') as file:
            key = os.path.splitext(filename)[0]
            templates[key] = file.read()
    return templates

def parse_code_string(code_string):
    """
    Parses a code string and extracts code sections.

    Args:
        code_string (str): The code string to parse.

    Returns:
        list: A list of tuples containing the filenames, languages, and contents of the code sections.
    """
    sections = code_string.split('---')
    
    pattern = re.compile(r'^(.+)\n```(.+?)\n(.*?)\n```', re.DOTALL)
    
    code_triples = []

    for section in sections:
        match = pattern.match(section)
        if match:
            filename, language, code = match.groups()
            code_triples.append((section.split("\n```")[0], language.strip(), code.strip()))
    
    return code_triples

def read_gitignore(path):
    """
    Reads the patterns from a .gitignore file.

    Args:
        path (str): The path to the directory where the .gitignore file is located.

    Returns:
        list: A list of file patterns to be ignored.
    """
    gitignore_path = os.path.join(path, '.gitignore')
    patterns = []
    if os.path.exists(gitignore_path):
        with open(gitignore_path, 'r') as file:
            for line in file:
                line = line.strip()
                if line and not line.startswith('#'):
                    patterns.append(line)
    return patterns

def is_ignored(entry_path, gitignore_patterns):
    """
    Checks if a file or directory should be ignored based on the gitignore patterns.

    Args:
        entry_path (str): The path to the file or directory to check.
        gitignore_patterns (list): A list of gitignore patterns.

    Returns:
        bool: True if the file or directory should be ignored, False otherwise.
    """
    for pattern in gitignore_patterns:
        if fnmatch.fnmatch(entry_path, pattern):
            return True
    return False

def build_directory_structure(path='.', indent='', is_last=True, parent_prefix='', is_root=True):
    """
    Builds a tree structure representation of a directory.

    Args:
        path (str): The path to the directory to build the structure for.
        indent (str): The indentation string.
        is_last (bool): Indicates if the directory is the last entry in its parent directory.
        parent_prefix (str): The prefix to use for the parent directories.
        is_root (bool): Indicates if the directory is the root directory.

    Returns:
        str: The directory structure represented as a string.
    """
    gitignore_patterns = read_gitignore(path) + [".gitignore", "*gpt_migrate/*"] if indent == '' else ["*gpt_migrate/*"]

    base_name = os.path.basename(path)

    if not base_name:
        base_name = '.'

    if indent == '':
        prefix = '|-- ' if not is_root else ''
    elif is_last:
        prefix = parent_prefix + '└── '
    else:
        prefix = parent_prefix + '├── '

    if os.path.isdir(path):
        result = indent + prefix + base_name + '/\n' if not is_root else ''
    else:
        result = indent + prefix + base_name + '\n'

    if os.path.isdir(path):
        entries = os.listdir(path)
        for index, entry in enumerate(entries):
            entry_path = os.path.join(path, entry)
            new_parent_prefix = '    ' if is_last else '│   '
            if not is_ignored(entry_path, gitignore_patterns):
                result += build_directory_structure(entry_path, indent + '    ', index == len(entries) - 1, parent_prefix + new_parent_prefix, is_root=False)

    return result

def copy_files(sourcedir, targetdir, excluded_files=[]):
    """
    Copies files from a source directory to a target directory.

    Args:
        sourcedir (str): The path to the source directory.
        targetdir (str): The path to the target directory.
        excluded_files (list): A list of files to exclude from the copying process.
    """
    gitignore_patterns = read_gitignore(sourcedir) + [".gitignore"]
    for item in os.listdir(sourcedir):
        if os.path.isfile(os.path.join(sourcedir, item)):
            if item.endswith(INCLUDED_EXTENSIONS) and item not in excluded_files:
                if not is_ignored(item, gitignore_patterns):
                    os.makedirs(targetdir, exist_ok=True)
                    shutil.copy(os.path.join(sourcedir, item), targetdir)
                    typer.echo(typer.style(f"Copied {item} from {sourcedir} to {targetdir}", fg=typer.colors.GREEN))
        else:
            copy_files(os.path.join(sourcedir, item), os.path.join(targetdir, item))

def construct_relevant_files(files):
    """
    Constructs a string representing relevant files.

    Args:
        files (list): A list of tuples containing the names and contents of relevant files.

    Returns:
        str: The string representing the relevant files.
    """
    ret = ""
    for file in files:
        name = file[0]
        content = file[1]
        ret += name+":\n\n" + "```\n"+content+"\n```\n\n"
    return ret

def file_exists_in_memory(filename):
    """
    Checks if a file exists in memory.

    Args:
        filename (str): The name of the file.

    Returns:
        bool: True if the file exists in memory, False otherwise.
    """
    file = Path('memory/' + filename)
    return file.exists()

def convert_sigs_to_string(sigs):
    """
    Converts a list of signatures to a string representation.

    Args:
        sigs (list): A list of signatures.

    Returns:
        str: The string representation of the signatures.
    """
    sig_string = ""
    for sig in sigs:
        sig_string += sig["signature"] + "\n" + sig["description"] + "\n\n"
    return sig_string

def write_to_memory(filename,content):
    """
    Writes content to memory file.

    Args:
        filename (str): The name of the memory file.
        content (str): The content to write.
    """
    with open('memory/'+filename, 'a+') as file:
        for item in content:
            if item not in file.read().split("\n"):
                file.write(item+'\n')

def read_from_memory(filename):
    """
    Reads content from memory file.

    Args:
        filename (str): The name of the memory file.

    Returns:
        str: The content of the memory file.
    """
    content = ""
    with open('memory/'+filename, 'r') as file:
        content = file.read()
    return content

def find_and_replace_file(filepath,find,replace):
    """
    Finds and replaces a string in a file.

    Args:
        filepath (str): The path to the file.
        find (str): The string to find.
        replace (str): The string to replace the found string with.
    """
    with open(filepath, 'r') as file:
        testfile_content = file.read()
    testfile_content = testfile_content.replace(find,replace)
    with open(filepath, 'w') as file:
        file.write(testfile_content)